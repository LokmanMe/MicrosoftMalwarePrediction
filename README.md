*Instructions: Click on the raw button in the upper right hand corner of this box.  Copy and paste the template into the README.md document on your github.  Fill in the titles, information and links where prompted! Feel free to stray a bit to suit your project but try to stick to the format as closely as possible for consistency across DSWG projects.*

# Microsoft Malware Prediction - Prédire si une machine sera bientôt frappée d'un virus
Ce projet est basé sur une [compétition Kaggle](https://www.kaggle.com/c/microsoft-malware-prediction/overview) organisée par : Microsoft, Windows Defender ATP Research, Northeastern University College of Computer and Information Science, et Georgia Tech Institute for Information Security & Privacy.

#### -- Statut du projet : Terminé

## Introduction
L'industrie des logiciels malveillants continue d'être un marché bien organisé et très rentable qui se consacre à échapper aux mesures de sécurité traditionnelles. Une fois qu'un ordinateur est infecté par un logiciel malveillant, les criminels peuvent nuire aux consommateurs et aux entreprises de nombreuses façons (notamment par le chantage comme c’était le cas en mai 2017 avec le ransomware WannaCrypt).

Le but de ce projet est de prédire la probabilité qu'une machine Windows soit infectée par un logiciel malveillant, en fonction des différentes propriétés de cette machine. De ce fait, il sera plus aisé de déterminer les failles et de les corriger soit par des patchs soit pour les nouvelles machines. 

Ce projet a été réalisé dans le cadre de mon Master 2 Mathématiques Appliquées, Data science à l'Université d'Aix-Marseille.

### Méthodes utilisées
* • Traitement de données massives
* • Optimisation
* • Statistique exploratoire
* • Analyse prédictive
* • Visualisation de données
* • Machine Learning

### Technologies
* • Python
  * → numpy
  * → pandas
  * → matplotlib
  * → seaborn 

___________________
  
## Description du projet

### Données :
- Un fichier train.csv **(d’une taille de 4.2 Go)**

- Un fichier test.csv **(d’une taille de 3.8 Go)**

Le fichier train.csv possède **8,9 millions de lignes** (chacune correspond à une machine unique identifiée par la variable MachineIdentifier) et 83 colonnes labellisées. La dernière colonne de cette table de données correspond à la variable HasDetections qui informe si la machine a été infectée (HasDetections = 1) ou non (HasDetections = 0).

Le fichier test.csv possède **7,8 millions de lignes** et **82 colonnes**. La 83ème colonne sera une variable HasDetections à créer et correspondra à la probabilité que la machine soit infectée. Cette variable sera un nombre réel compris entre 0,0 et 1,0.

Le nom est la signification des variables est disponible dans le fichier dictionnaire.pdf

Le plus grand défi de cette compétition est donc de traiter ces tables de données de **grande dimension**. En effet, le simple fait d’importer la table de données d’entrainement via la méthode classique *read_csv* fait planter le processus et parfois même le système dans son entièreté à cause d’un dépassement de mémoire vive.


<p align="center">
  <img src="https://i.imgur.com/dqY1BvY.png" />
</p>


La solution a été de reformater les variables. En effet, Python formate automatiquement les variables en : **object**, **float64** et **int64** qui sont tous les trois codés sur 8 octets. Pourtant certaines variables ne possèdent que des valeurs binaires, on demande donc une place de 8 octets pour la remplir avec une valeur de 1 octet.

C’est pourquoi les variables contenant seulement des valeurs binaires ont été reformatées en **int8**, celles contenant des valeurs binaires mais aussi des NaN ont été reformatées en **float16**. Toutes les variables numériques encodées en **int64** et **float64** ont été reformatées respectivement en **int32** et **float32**.

De cette façon, au chargement des données **on passe de 37 Go d'utilisation de la mémoire à 1,6 Go**. Le gain est énorme, il se compte en facteur 24.

### Tris à plat et manipulation des données 

Nous commençons par regarder le type des variables de la table de données :

```python
train.info();

dtypes: category(30), float16(27), float32(9), int16(5), int32(1), int8(11)
```

Nous remarquons que les données sont composées de **30 variables catégorielles** et **53 variables numériques**. Les variables qui risquent de poser problèmes sont les variables catégorielles car elles ne peuvent être comprises par un algorithme de manière brute.

→ Distribution de la part des machines infectées et non-infectées par un virus (variable à prédire)

<p align="left">
  <img width=500 src="Figures/Figure_1.png" />
</p>

La moitié des machines de la table de données est infectée par un virus. La variable cible est bien équilibrée. Cela devrait faciliter la prédiction sur les données test (qui sont elles aussi équilibrées de la même manière d’après l’organisateur de la compétition)

